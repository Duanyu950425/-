# 2018校招真题

## 1. 拼多多——最大乘积

**题目**：给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1)

**输入描述**：无序整数数组A[n]

**输出描述**：满足条件的最大乘积

**示例**：输入：3 4 1 2

​           输出 ：24

**解题思路**：用选择排序的思路找到最大的3个数和最小的3个数。

最大乘积有以下情况：

（1） 最大的三个数相乘（全为正数，全为负数， 前两个为整数，后面为负数）

（2） 最小的负数与最大的正数相乘（负负得正，再与最大的相乘）

```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn = 1e6;
long long arr[maxn];

int main()
{
    int n;
    cin >> n;
    long long maxi[3], mini[3], ans;
    for(int i = 0; i < n; i++)
        cin >> arr[i];
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[i])
                swap(arr[j], arr[i]);
    maxi[0] = arr[0];
	maxi[1] = arr[1];
	maxi[2] = arr[2];
	mini[0] = arr[n - 3];
	mini[1] = arr[n - 2];
	mini[2] = arr[n - 1];
   	if (n == 3)
		ans = maxi[0] * maxi[1] * maxi[2];
	else
		ans = max (maxi[0]*maxi[1]*maxi[2], maxi[0]*mini[1]*mini[2]);
	cout << ans << endl;
	return 0;
}
```

## 2. 拼多多——大整数相乘

**题目**：有两个用字符串表示的非常大的大整数,算出他们的乘积，也是用字符串表示。不能用系统自带的大整数类型。

**输入描述**：空格分隔的两个字符串，代表输入的两个大整数

**输出描述**：输入的乘积，用字符串表示

**示例**：输入：72106547548473106236   982161082972751393

​           输出 ：70820244829634538040848656466105986748

**解题思路**：

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;

int main()
{
    string num1, num2;
    string s = "";
    cin >> num1 >> num2;
    int len1 = num1.size();
    int len2 = num2.size();
    vector<int> vTemp(len1 + len2 - 1);
    int n1, n2;
    for (int i = 0; i < len1; i++)
    {
        n1 = num1[i] - '0';
        for (int j = 0; j < len2; j++)
        {
            n2 = num2[i] - '0';
            vTemp[i + j] += n1*n2;
        }
    }
    int carry = 0;
    int temp;
    for (int i = vTemp.size() - 1; i >= 0; i--)
    {
        temp = vTemp[i] + carry;
        vTemp[i] = temp % 10;
        s = to_string(vTemp[i]) + s;
        carry = temp / 10;
    }
    if (carry > 0)
        s = to_string(carry) + s;
    cout << s << endl;
    return 0;
}
```

## 2. 拼多多——六一儿童节

**题目**：六一儿童节，老师带了很多好吃的巧克力到幼儿园。每块巧克力j的重量为w[j]，对于每个小朋友i，当他分到的巧克力大小达到h[i] (即w[j]>=h[i])，他才会上去表演节目。老师的目标是将巧克力分发给孩子们，使得最多的小孩上台表演。可以保证每个w[i]> 0且不能将多块巧克力分给一个孩子或将一块分给多个孩子。

**输入描述**：第一行：n，表示h数组元素个数

​				   第二行：n个h数组元素

​				   第三行：m，表示w数组元素个数

​				   第四行：m个w数组元素

**输出描述**：上台表演学生人数

**示例**：输入：3 

​					   2 2 3

​					   2

​					   3 1

​           输出 ：1

**解题思路**：先将两个数组从小到大排序，然后吃的最少的小朋友先选最少的巧克力，依次往后。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn = 1e6;
int h[maxn], w[maxn];

int main()
{
    int n, m;
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> h[i];
    cin >> m;
    for (int i = 0; i < m; i++)
        cin >> w[i];
    int i = 0, j = 0, res = 0;
    while (i < n && j < m)
    {
        if (h[i] <= w[j])
        {
            res++;
            i++;
            j++;
        }
        else
            j++;
    }
    cout << res << end;
    return 0;
}
```

## 3. 拼多多——迷宫寻路

**题目**：假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是路。迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。请设计一个算法，帮助探险家找到脱困的最短路径。如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下 0-墙，1-路，2-探险家的起始位置，3-迷宫的出口，大写字母-门，小写字母-对应大写字母所代表的门的钥匙

**输入描述**：迷宫的地图，用二维矩阵表示。第一行是表示矩阵的行数和列数M和N

​				   后面的M行是矩阵的数据，每一行对应与矩阵的一行（中间没有空格）。M和N都不超过100, 门不超过10扇。

**输出描述**：路径的长度，是一个整数

**示例**：输入：5 5

​                       02111

​                       01a0A

​                       01003

​                       01001

​                       01111

​           输出 ：7

**解题思路**：

## 4. 网易——彩色的砖块

**题目**：小易有一些彩色的砖块。每种颜色由一个大写字母表示。各个颜色砖块看起来都完全一样。现在有一个给定的字符串s,s中每个字符代表小易的某个砖块的颜色。小易想把他所有的砖块排成一行。如果最多存在一对不同颜色的相邻砖块,那么这行砖块就很漂亮的。请你帮助小易计算有多少种方式将他所有砖块排成漂亮的一行。(如果两种方式所对应的砖块颜色序列是相同的,那么认为这两种方式是一样的。)

​		  例如: s = "ABAB",那么小易有六种排列的结果:
"AABB","ABAB","ABBA","BAAB","BABA","BBAA"
其中只有"AABB"和"BBAA"满足最多只有一对不同颜色的相邻砖块。

**输入描述**：输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s中的每一个字符都为一个大写字母(A到Z)。

**输出描述**：输出一个整数,表示小易可以有多少种方式。

**示例**：输入：ABAB

​           输出 ：2

**解题思路**：当输入的颜色只有一种时，则只有一种排序方式；当输入的颜色有两种，排序方式有两种；当输入的颜色超过2时，没有能达到要求的排序方式。

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main()
{
    string str;
    int res = 0;
    cin >> str;
    sort(str.begin(), str.end());
    str.erase(unique(str.begin(), str.end()), str.end());
    if (str.size() == 1)
        res = 1;
    else if (str.size() == 2)
        res = 2;
    cout << res << endl;
    return 0;
}
```

## 5. 网易——等差数列

**题目**：如果一个数列S满足对于所有的合法的i，都有S[i + 1] = S[i] + d, 这里的d也可以是负数和零,我们就称数列S为等差数列。

​		   小易现在有一个长度为n的数列x,小易想把x变为一个等差数列。小易允许在数列上做交换任意两个位置的数值的操作,并且交换操作允许交换多次。但是有些数列通过交换还是不能变成等差数列,小易需要判别一个数列是否能通过交换操作变成等差数列

**输入描述**：输入包括两行,第一行包含整数n(2 ≤ n ≤ 50),即数列的长度。

​				   第二行n个元素x[i](0 ≤ x[i] ≤ 1000),即数列中的每个整数。

**输出描述**：如果可以变成等差数列输出"Possible",否则输出"Impossible"。

**示例**：输入：3

​	                   3  1  2

​           输出 ：Possible

**解题思路**：对于等差数列来说，相邻两个数的差值一定相同，且应当为从小到大或从大到小排列的数列。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int n;
    cin >> n;
    int *x = new int[n];
    for (int i = 0; i < n; i++)
        cin >> x[i];
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
            if (a[j] < a[i])
                swap (a[j], a[i]);
    int d = x[1] - x[0];
    for (int i = n - 1; i > 0; i--)
        if (x[i] - x[i - 1] != d)
        {
            cout << "Imposiible" << endl;
            return 0;
        }
    cout << "possible" << endl;
    return 0;
}
```

## 6. 网易——交错01串

**题目**：如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: "1","10101","0101010"都是交错01串。

​		   小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙求出最长的这样的子串的长度是多少。

**输入描述**：输入包括字符串s,s的长度length(1 ≤ length ≤ 50),字符串中只包含'0'和'1'

**输出描述**：输出一个整数,表示最长的满足要求的子串长度。

**示例**：输入：111101111

​           输出 ：3

**解题思路**：这是一道送分题啊！！！！

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

int main()
{
    string s;
    cin >> s;
    int Max_len = 1, len = 1;
    for (int i = 0; i , s.length(); i++)
    {
        if (s[i + 1] != s[i])
        {
            len++;
            Max_len = max(len, Max_len);
        }
        else
            len = 1;
    }
    cout << Max_len << endl;
}
```

## 7. 网易——操作序列

**题目**：小易有一个长度为n的整数序列,a_1,...,a_n。然后考虑在一个空序列b上进行n次以下操作:

1、将a_i放入b序列的末尾

2、逆置b序列

小易需要你计算输出操作n次之后的b序列。

**输入描述**：输入包括两行,第一行包括一个整数n(2 ≤ n ≤ 2*10^5),即序列的长度。

​		           第二行包括n个整数a_i(1 ≤ a_i ≤ 10^9),即序列a中的每个整数,以空格分割。

**输出描述**：在一行中输出操作n次之后的b序列,以空格分割,行末无空格。

**示例**：输入：4

​					   1   2   3   4

​           输出 ：4   2   1   3

**解题思路**：这其实是一道规律题。链接：

n = 1,b = 1    n = 1直接输出

n = 2,b = 2,1

n = 3,b = 3,1,2

n = 4,b = 4,2,1,3

n = 5,b = 5,3,1,2,4

n = 6,b = 6,4,2,1,3,5

由上述可推，当n 为奇数时，

先从后向前输出奇数位置的数字，再从前向后输出偶数位置的数字  
当n 为偶数时

先从后向前输出偶数位置的数字，再从前向后输出奇数位置的数字

```c++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    if (n == 1)
    {
        cout << a[0] << endl;
        return 0;
    }
    if (n % 2 == 0)
    {
        for (int i = n - 1; i >= 0; i -= 2)
            cout << a[i] << " ";
        cout << a[0] << " ";
        for (int i = 2; i < n - 1; i += 2)
            cout << a[i] << " ";
    }
    else
    {
        for (int i = n - 1; i >= 0; i -= 2)
            cout << a[i] << endl;
        cout << a[1] << " ";
        for (int i = 3; i < n - 1; i += 2)
            cout << a[i] << " ";
    }
    cout << endl;
    return 0;
}
```

## 8. 网易——独立的小易

**题目**：小易为了向他的父母表现他已经长大独立了,他决定搬出去自己居住一段时间。一个人生活增加了许多花费: 小易每天必须吃一个水果并且需要每天支付x元的房屋租金。当前小易手中已经有f个水果和d元钱,小易也能去商店购买一些水果,商店每个水果售卖p元。小易为了表现他独立生活的能力,希望能独立生活的时间越长越好,小易希望你来帮他计算一下他最多能独立生活多少天。

**输入描述**：输入包括一行,四个整数x, f, d, p(1 ≤ x,f,d,p ≤ 2 * 10^9),以空格分割

**输出描述**：输出一个整数, 表示小易最多能独立生活多少天。

**示例**：输入：3   5   100   10

​           输出 ：11

**解题思路**：1. 已有f个水果，说明f天可以不用买水果。如果小易现有的钱不够这f天的房租，则他顶多住d/x天；

​                   2. 如果现有的钱够这f天的房租，则通过数学公式可求得

```c++
#include<iostream>
using namespace std;
int main()
{
    long x, f, d, p;
    cin >> x >> f >> d >> p;
    int day;
    if (d - x * f <= 0)
        day = d / x;
    else
        day = (d + f * p) / (x + p);
    cout << day << endl;
    return 0;
}
```

## 9. 网易——堆棋子

**题目**：小易将n个棋子摆放在一张无限大的棋盘上。第i个棋子放在第x[i]行y[i]列。同一个格子允许放置多个棋子。每一次操作小易可以把一个棋子拿起并将其移动到原格子的上、下、左、右的任意一个格子中。小易想知道要让棋盘上出现有一个格子中至少有i(1 ≤ i ≤ n)个棋子所需要的最少操作次数.

**输入描述**：输入包括三行,第一行一个整数n(1 ≤ n ≤ 50),表示棋子的个数

​				   第二行为n个棋子的横坐标x[i] (1 ≤ x[i] ≤ 10^9)

​				   第三行为n个棋子的纵坐标y[i] (1 ≤ y[i] ≤ 10^9)

**输出描述**：输出n个整数,第i个表示棋盘上有一个格子至少有i个棋子所需要的操作数,以空格分割。行末无空格

如样例所示:

​				   对于1个棋子: 不需要操作

​				   对于2个棋子:  将前两个棋子放在(1, 1)中

​				   对于3个棋子: 将前三个棋子放在(2, 1)中

 				  对于4个棋子: 将所有棋子都放在(3, 1)中

**示例**：输入：4

​					   1   2    4   9

​					   1   1    1    1

​           输出 ：0   1   3   10

**解题思路**：